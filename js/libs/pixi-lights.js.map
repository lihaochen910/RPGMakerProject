{"version":3,"file":"pixi-lights.js","sources":["../src/mixins/Circle.js","../src/main.js","../src/lights/light/Light.js","../src/lights/light/LightShader.js","../src/lights/ambientLight/AmbientLight.js","../src/lights/ambientLight/AmbientLightShader.js","../src/lights/pointLight/PointLight.js","../src/lights/pointLight/point.frag.js","../src/lights/pointLight/PointLightShader.js","../src/lights/directionalLight/DirectionalLight.js","../src/lights/directionalLight/directional.frag.js","../src/lights/directionalLight/DirectionalLightShader.js","../src/renderers/LightRenderer.js","../src/lights/wireframe/WireframeShader.js"],"sourcesContent":["/**\n * Contains mixins for the `PIXI.Circle` class.\n * @class Circle\n * @memberof PIXI\n * @see http://pixijs.download/release/docs/PIXI.Circle.html\n */\n/**\n * Creates vertices and indices arrays to describe this circle.\n * @method PIXI.Circle#getMesh\n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\n * @param [verticesOutput] {Float32Array} An array to output the vertices into. Length must be\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\n * @param [indicesOutput] {Uint16Array} An array to output the indices into, in gl.TRIANGLE_FAN format. Length must\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\n * @return {PIXI.Circle~MeshData} Object with verticies and indices arrays\n */\nPIXI.Circle.prototype.getMesh = function getMesh(totalSegments = 40, vertices, indices) {\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\n    indices = indices || new Uint16Array(totalSegments + 1);\n\n    let seg = (Math.PI * 2) / totalSegments,\n        indicesIndex = -1;\n\n    indices[++indicesIndex] = indicesIndex;\n\n    for (let i = 0; i <= totalSegments; ++i) {\n        let index = i*2;\n        let angle = seg * i;\n\n        vertices[index] = Math.cos(angle) * this.radius;\n        vertices[index+1] = Math.sin(angle) * this.radius;\n\n        indices[++indicesIndex] = indicesIndex;\n    }\n\n    indices[indicesIndex] = 1;\n\n    return { vertices, indices };\n};\n\n/**\n * @typedef PIXI.Circle~MeshData\n * @property {Float32Array} vertices - Vertices data\n * @property {Uint16Array} indices - Indices data\n */\n","/**\n * @namespace PIXI.lights\n */\n\n/**\n * @static\n * @memberof PIXI.lights\n * @member {Object}\n */\nconst plugins = {};\n\n/**\n * @static\n * @memberof PIXI.lights\n * @member {PIXI.display.Group}\n */\nconst diffuseGroup = new PIXI.display.Group();\n\n/**\n * @static\n * @memberof PIXI.lights\n * @member {PIXI.display.Group}\n */\nconst normalGroup = new PIXI.display.Group();\n\n/**\n * @static\n * @memberof PIXI.lights\n * @member {PIXI.display.Group}\n */\nconst lightGroup = new PIXI.display.Group();\n\ndiffuseGroup.useRenderTexture = true;\nnormalGroup.useRenderTexture = true;\n\n/**\n * @static\n * @memberof PIXI.lights\n * @param {string} name - Name of the plugin\n * @param {class} classRef - Class references\n */\nfunction registerPlugin(name, classRef) {\n    plugins[name] = classRef;\n}\n\nexport {\n    plugins,\n    diffuseGroup,\n    normalGroup,\n    lightGroup,\n    registerPlugin\n};\n","import {lightGroup} from '../../main';\n\n/**\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\n */\nexport default class Light extends PIXI.Container {\n    constructor(color, brightness, vertices, indices) {\n        super();\n\n        /**\n         * An array of vertices\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = vertices || new Float32Array(8);\n\n        /**\n         * An array containing the indices of the vertices\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = indices || new Uint16Array([0,1,2, 0,2,3]);\n\n        /**\n         * The blend mode to be applied to the light.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.ADD\n         * @see http://pixijs.download/release/docs/PIXI.html#.BLEND_MODES\n         */\n        this.blendMode = PIXI.BLEND_MODES.ADD;\n\n        /**\n         * The draw mode to be applied to the light geometry.\n         *\n         * @member {number}\n         * @default PIXI.DRAW_MODES.TRIANGLES\n         * @see http://pixijs.download/release/docs/PIXI.html#.DRAW_MODES\n         */\n        this.drawMode = PIXI.DRAW_MODES.TRIANGLES;\n\n        /**\n         * When incremented the renderer will re-upload indices\n         *\n         * @member {number}\n         */\n        this.dirty = 0;\n\n        /**\n         * The height of the light from the viewport.\n         *\n         * @member {number}\n         * @default 0.075\n         */\n        this.lightHeight = 0.075;\n\n        /**\n         * The falloff attenuation coeficients.\n         *\n         * @member {number[]}\n         * @default [0.75, 3, 20]\n         */\n        this.falloff = [0.75, 3, 20];\n\n        /**\n         * The name of the shader plugin to use.\n         *\n         * @member {string}\n         */\n        this.shaderName = null;\n\n        /**\n         * By default the light uses a viewport sized quad as the mesh.\n         */\n        this.useViewportQuad = true;\n\n        // color and brightness are exposed through setters\n        this._color = 0x4d4d59;\n        this._colorRgba = [0.3, 0.3, 0.35, 0.8];\n\n        // run the color setter\n        if (color || color === 0) {\n            this.color = color;\n        }\n\n        // run the brightness setter\n        if (brightness || brightness === 0) {\n            this.brightness = brightness;\n        }\n\n        this.parentGroup = lightGroup;\n\n\n        /**\n         * WebGL data for this light\n         * @member {Object}\n         * @private\n         */\n        this._glDatas = {};\n\n        this.shaderName = 'lights';\n    }\n\n    /**\n     * The color of the lighting.\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    get color() {\n        return this._color;\n    }\n    set color(val) {\n        this._color = val;\n        PIXI.utils.hex2rgb(val, this._colorRgba);\n    }\n\n    /**\n     * The brightness of this lighting. Normalized in the range [0, 1].\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    get brightness() {\n        return this._colorRgba[3];\n    }\n    set brightness(val) {\n        this._colorRgba[3] = val;\n    }\n\n    syncShader(shader) {\n        shader.uniforms.uUseViewportQuad = this.useViewportQuad;\n\n        let uLightColor = shader.uniforms.uLightColor;\n        if (uLightColor) {\n            uLightColor[0] = this._colorRgba[0];\n            uLightColor[1] = this._colorRgba[1];\n            uLightColor[2] = this._colorRgba[2];\n            uLightColor[3] = this._colorRgba[3];\n            shader.uniforms.uLightColor = uLightColor;\n        }\n\n        shader.uniforms.uLightHeight = this.lightHeight;\n\n        let uLightFalloff = shader.uniforms.uLightFalloff;\n        if (uLightFalloff) {\n            uLightFalloff[0] = this.falloff[0];\n            uLightFalloff[1] = this.falloff[1];\n            uLightFalloff[2] = this.falloff[2];\n            shader.uniforms.uLightFalloff = uLightFalloff;\n        }\n    }\n\n    _renderWebGL(renderer) {\n        renderer.setObjectRenderer(renderer.plugins.lights);\n        renderer.plugins.lights.render(this);\n    }\n}\n","import vertex from './light.vert';\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class LightShader extends PIXI.Shader {\n    constructor(gl, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\n        const uniforms = {\n            translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\n\n            // textures from the previously rendered FBOs\n            uSampler:       { type: 'sampler2D', value: null },\n            uNormalSampler: { type: 'sampler2D', value: null },\n\n            // should we apply the translation matrix or not.\n            uUseViewportQuad: { type: 'bool', value: true },\n\n            // size of the renderer viewport, CSS\n            uViewSize:      { type: '2f', value: new Float32Array(2) },\n            //same, in PIXELS\n            uViewPixels:    { type: '2f', value: new Float32Array(2) },\n\n            // light color, alpha channel used for intensity.\n            uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\n\n            // light falloff attenuation coefficients\n            uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) },\n\n            // height of the light above the viewport\n            uLightHeight: { type: '1f', value: 0.075 }\n        };\n\n        if (customUniforms) {\n            for (const u in customUniforms) {\n                uniforms[u] = customUniforms[u];\n            }\n        }\n\n        const attributes = {\n            aVertexPosition: 0\n        };\n\n        if (customAttributes) {\n            for (const a in customAttributes) {\n                attributes[a] = customAttributes[a];\n            }\n        }\n\n        super(gl, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc, attributes);\n    }\n}\n\n/**\n * @static\n * @member {string}\n */\nLightShader.defaultVertexSrc = vertex;\n","import Light from '../light/Light';\n\n/**\n * Ambient light is drawn using a full-screen quad\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=0.5] {number} The brightness of the light.\n */\nexport default class AmbientLight extends Light {\n    constructor(color=0xFFFFFF, brightness=0.5) {\n        super(color, brightness);\n        this.shaderName = 'ambientLightShader';\n    }\n}\n","import {registerPlugin} from '../../main';\nimport LightShader from '../light/LightShader';\nimport fragment from './ambient.frag';\n\n/**\n * @class\n * @extends PIXI.lights.LightShader\n * @memberof PIXI.lights\n * @param gl {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class AmbientLightShader extends LightShader {\n    constructor(gl) {\n        super(gl, null, fragment);\n    }\n}\n\nregisterPlugin('ambientLightShader', AmbientLightShader);\n","import Light from '../light/Light';\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [radius=Infinity] {number} The distance the light reaches. You will likely need\n *  to change the falloff of the light as well if you change this value. Infinity will\n *  use the entire viewport as the drawing surface.\n */\nexport default class PointLight extends Light {\n    constructor(color=0xFFFFFF, brightness=1, radius=Infinity) {\n        if (radius !== Infinity) {\n            const shape = new PIXI.Circle(0, 0, radius);\n            const {vertices, indices} = shape.getMesh();\n\n            super(color, brightness, vertices, indices);\n\n            this.useViewportQuad = false;\n            this.drawMode = PIXI.DRAW_MODES.TRIANGLE_FAN;\n        }\n        else {\n            super(color, brightness);\n        }\n        this.radius = radius;\n        this.shaderName = 'pointLightShader';\n    }\n\n    syncShader(shader) {\n        super.syncShader(shader);\n        shader.uniforms.uLightRadius = this.radius;\n    }\n}\n","import commonUniforms from '../shared/commonUniforms.glsl';\nimport computeVertexPosition from '../shared/computeVertexPosition.glsl';\nimport loadNormals from '../shared/loadNormals.glsl';\nimport computeDiffuse from '../shared/computeDiffuse.glsl';\nimport combine from '../shared/combine.glsl';\n\nexport default `precision highp float;\n\n// imports the common uniforms like samplers, and ambient color\n${commonUniforms}\n\nuniform float uLightRadius;\n\nvoid main()\n{\n${computeVertexPosition}\n${loadNormals}\n\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\n\n    // correct for aspect ratio\n    lightVector.x *= uViewSize.x / uViewSize.y;\n\n    // compute Distance\n    float D = length(lightVector);\n\n    // bail out early when pixel outside of light sphere\n    if (D > uLightRadius) discard;\n\n${computeDiffuse}\n\n    // calculate attenuation\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\n\n${combine}\n}\n`;\n","import {registerPlugin} from '../../main';\nimport LightShader from '../light/LightShader';\nimport fragment from './point.frag';\n\n/**\n * @class\n * @extends PIXI.lights.LightShader\n * @memberof PIXI.lights\n * @param gl {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class PointLightShader extends LightShader {\n    constructor(gl) {\n        super(gl, null, fragment, {\n            // height of the light above the viewport\n            uLightRadius: {\n                type: '1f',\n                value: 1\n            }\n        });\n    }\n}\n\nregisterPlugin('pointLightShader', PointLightShader);\n","import Light from '../light/Light';\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [target] {PIXI.DisplayObject|PIXI.Point} The object in the scene to target.\n */\nexport default class DirectionalLight extends Light {\n    constructor(color=0xFFFFFF, brightness=1, target) {\n        super(color, brightness);\n\n        this.target = target;\n        this._directionVector = new PIXI.Point();\n        this.shaderName = 'directionalLightShader';\n    }\n\n    updateTransform() {\n        this.containerUpdateTransform();\n\n        let vec = this._directionVector,\n            wt = this.worldTransform,\n            tx = this.target.worldTransform ? this.target.worldTransform.tx : this.target.x,\n            ty = this.target.worldTransform ? this.target.worldTransform.ty : this.target.y;\n\n        // calculate direction from this light to the target\n        vec.x = wt.tx - tx;\n        vec.y = wt.ty - ty;\n\n        // normalize\n        const len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n        vec.x /= len;\n        vec.y /= len;\n    }\n\n    syncShader(shader) {\n        super.syncShader(shader);\n\n        const uLightDirection = shader.uniforms.uLightDirection;\n        uLightDirection[0] = this._directionVector.x;\n        uLightDirection[1] = this._directionVector.y;\n        shader.uniforms.uLightDirection = uLightDirection;\n    }\n}\n","import commonUniforms from '../shared/commonUniforms.glsl';\nimport computeVertexPosition from '../shared/computeVertexPosition.glsl';\nimport loadNormals from '../shared/loadNormals.glsl';\nimport computeDiffuse from '../shared/computeDiffuse.glsl';\nimport combine from '../shared/combine.glsl';\n\nexport default `precision highp float;\n\n// imports the common uniforms like samplers, and ambient/light color\n${commonUniforms}\n\nuniform vec2 uLightDirection;\n\nvoid main()\n{\n${computeVertexPosition}\n${loadNormals}\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\n\n    // compute Distance\n    float D = length(lightVector);\n\n${computeDiffuse}\n\n    // calculate attenuation\n    float attenuation = 1.0;\n\n${combine}\n}\n`;","import {registerPlugin} from '../../main';\nimport LightShader from '../light/LightShader';\nimport fragment from './directional.frag';\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class DirectionalLightShader extends LightShader {\n    constructor(gl) {\n        super(gl, null, fragment, {\n            // the directional vector of the light\n            uLightDirection: {\n                type: '2f',\n                value: new Float32Array(2)\n            }\n        });\n    }\n}\n\nregisterPlugin('directionalLightShader', DirectionalLightShader);\n","import {plugins, normalGroup, diffuseGroup} from '../main';\n\n/**\n * @class\n * @private\n * @memberof PIXI.lights\n * @extends PIXI.ObjectRenderer\n * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.\n */\nexport default class LightRenderer extends PIXI.ObjectRenderer {\n    constructor(renderer) {\n        super(renderer);\n\n        // the total number of indices in our batch, there are 6 points per quad.\n        const numIndices = LightRenderer.MAX_LIGHTS * 6;\n\n        /**\n         * Holds the indices\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = new Uint16Array(numIndices);\n\n        //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\n        for (let i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n            this.indices[i + 0] = j + 0;\n            this.indices[i + 1] = j + 1;\n            this.indices[i + 2] = j + 2;\n            this.indices[i + 3] = j + 0;\n            this.indices[i + 4] = j + 2;\n            this.indices[i + 5] = j + 3;\n        }\n\n        this.shaders = {};\n\n        /**\n         * The current lights in the batch.\n         *\n         * @member {Light[]}\n         */\n        this.lights = [];\n    }\n\n    onContextChange() {\n        this.gl = this.renderer.gl;\n        for (let key in plugins) {\n            this.shaders[key] = new (plugins[key])(this.gl);\n        }\n    }\n\n    /**\n     * Renders the light object.\n     * @private\n     * @param light {Light} the light to render\n     */\n    render(mesh) {\n        let renderer = this.renderer;\n        let gl = renderer.gl;\n\n        this.lights.push(mesh);\n        /**\n         * Prepares all the buffers to render this light.\n         */\n        let glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n        if (!glData) {\n            renderer.bindVao(null);\n\n            glData = {\n                shader: this.shaders[mesh.shaderName],\n                vertexBuffer: PIXI.glCore.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n                indexBuffer: PIXI.glCore.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n                // build the vao object that will render..\n                vao: null,\n                dirty: mesh.dirty\n            };\n\n            // build the vao object that will render..\n            glData.vao = new PIXI.glCore.VertexArrayObject(gl)\n                .addIndex(glData.indexBuffer)\n                .addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0);\n\n            mesh._glDatas[renderer.CONTEXT_UID] = glData;\n        }\n\n        renderer.bindVao(glData.vao);\n\n        if (mesh.useViewportQuad) {\n            mesh.vertices[2] = mesh.vertices[4] = renderer.screen.width;\n            mesh.vertices[5] = mesh.vertices[7] = renderer.screen.height;\n        }\n        glData.vertexBuffer.upload(mesh.vertices);\n\n        if (glData.dirty !== mesh.dirty) {\n            glData.dirty = mesh.dirty;\n            glData.indexBuffer.upload(mesh.indices);\n        }\n    }\n\n    flush() {\n        let diffuseTexture = null,\n            normalTexture = null,\n            lastLayer = null,\n            lastShader = null,\n            renderer = this.renderer;\n\n        for (let i = 0; i < this.lights.length; ++i) {\n            let light = this.lights[i],\n                layer = this.lights[i]._activeParentLayer;\n\n            if (!layer) {\n                continue;\n            }\n\n            if (lastLayer !== layer) {\n                lastLayer = layer;\n                let stage = layer._activeStageParent;\n\n                if (layer.diffuseTexture &&\n                    layer.normalTexture) {\n                    diffuseTexture = layer.diffuseTexture;\n                    normalTexture = layer.normalTexture;\n                }\n                else {\n                    for (let j = 0; j < stage._activeLayers.length; j++) {\n                        let texLayer = stage._activeLayers[j];\n                        if (texLayer.group === normalGroup) {\n                            normalTexture = texLayer.getRenderTexture();\n                        }\n                        if (texLayer.group === diffuseGroup) {\n                            diffuseTexture = texLayer.getRenderTexture();\n                        }\n                    }\n                }\n\n                renderer.bindTexture(diffuseTexture, 0, true);\n                renderer.bindTexture(normalTexture, 1, true);\n            }\n\n            let glData = light._glDatas[renderer.CONTEXT_UID],\n                shader = glData.shader;\n\n            if (lastShader !== shader) {\n                lastShader = shader;\n                renderer.bindShader(shader);\n\n                shader.uniforms.uSampler = 0;\n                shader.uniforms.uNormalSampler = 1;\n\n                let uViewSize = shader.uniforms.uViewSize;\n                if (uViewSize) {\n                    uViewSize[0] = renderer.screen.width;\n                    uViewSize[1] = renderer.screen.height;\n                    shader.uniforms.uViewSize = uViewSize;\n                }\n\n                let uViewPixels = shader.uniforms.uViewPixels;\n                if (uViewPixels) {\n                    uViewPixels[0] = renderer.view.width;\n                    uViewPixels[1] = renderer.view.height;\n                    shader.uniforms.uViewPixels = uViewPixels;\n                }\n\n                shader.uniforms.uFlipY = renderer._activeRenderTarget.root ? 1.0 : 0.0;\n            }\n\n            renderer.bindVao(glData.vao);\n\n            light.syncShader(shader);\n            renderer.state.setBlendMode(light.blendMode);\n            shader.uniforms.translationMatrix = light.worldTransform.toArray(true);\n\n            glData.vao.draw(light.drawMode, light.indices.length, 0);\n        }\n\n        this.lights.length = 0;\n    }\n\n    stop() {\n        this.flush();\n    }\n}\n\n/**\n * Maximum number of lights\n * @static\n * @member {number}\n */\nLightRenderer.MAX_LIGHTS = 500;\n\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\n","import {registerPlugin} from '../../main';\nimport vertex from './wireframe.vert';\nimport fragment from './wireframe.frag';\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class WireframeShader extends PIXI.Shader {\n    constructor(gl) {\n        super(gl, vertex, fragment, {\n            aVertexPosition: 0\n        });\n    }\n}\n\nregisterPlugin('wireframeShader', WireframeShader);\n"],"names":["PIXI","Circle","prototype","getMesh","totalSegments","vertices","indices","Float32Array","Uint16Array","let","seg","Math","PI","indicesIndex","i","index","angle","cos","radius","sin","plugins","diffuseGroup","display","Group","normalGroup","lightGroup","registerPlugin","name","classRef","useRenderTexture","Light","color","brightness","super","this","blendMode","BLEND_MODES","ADD","drawMode","DRAW_MODES","TRIANGLES","dirty","lightHeight","falloff","shaderName","useViewportQuad","_color","_colorRgba","parentGroup","_glDatas","prototypeAccessors","val","utils","hex2rgb","syncShader","shader","uniforms","uUseViewportQuad","uLightColor","uLightHeight","uLightFalloff","_renderWebGL","renderer","setObjectRenderer","lights","render","Container","LightShader","gl","vertexSrc","fragmentSrc","customUniforms","customAttributes","const","translationMatrix","type","value","projectionMatrix","uSampler","uNormalSampler","uViewSize","uViewPixels","u","attributes","aVertexPosition","a","defaultVertexSrc","Shader","AmbientLight","AmbientLightShader","fragment","PointLight","Infinity","TRIANGLE_FAN","uLightRadius","computeDiffuse","combine","PointLightShader","DirectionalLight","target","_directionVector","Point","updateTransform","containerUpdateTransform","vec","wt","worldTransform","tx","x","ty","y","len","sqrt","uLightDirection","commonUniforms","computeVertexPosition","loadNormals","DirectionalLightShader","LightRenderer","numIndices","MAX_LIGHTS","j","shaders","onContextChange","key","mesh","push","glData","CONTEXT_UID","bindVao","vertexBuffer","glCore","GLBuffer","createVertexBuffer","STREAM_DRAW","indexBuffer","createIndexBuffer","STATIC_DRAW","vao","VertexArrayObject","addIndex","addAttribute","FLOAT","screen","width","height","upload","flush","diffuseTexture","normalTexture","lastLayer","lastShader","length","light","layer","_activeParentLayer","stage","_activeStageParent","_activeLayers","texLayer","group","getRenderTexture","bindTexture","bindShader","view","uFlipY","_activeRenderTarget","root","state","setBlendMode","toArray","draw","stop","ObjectRenderer","WebGLRenderer","WireframeShader","vertex"],"mappings":"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"}